name: Deploy to all-inkl.com
# Deploy with database migration for created_by column

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: 8.4
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv, pdo_mysql
          coverage: none

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install Composer dependencies
        run: composer install --no-progress --prefer-dist --optimize-autoloader --no-dev

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets for production
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deployment-package

          # Copy application files
          rsync -av --exclude-from=deployment-excludes.txt . deployment-package/ || rsync -av --exclude='node_modules' --exclude='.git' --exclude='.github' --exclude='tests' --exclude='storage/logs' . deployment-package/

          # Create production .env file
          cat > deployment-package/.env << EOF
          APP_NAME="${{ secrets.APP_NAME }}"
          APP_ENV=production
          APP_KEY=
          APP_DEBUG=true
          APP_URL="${{ secrets.APP_URL }}"

          APP_LOCALE=de
          APP_FALLBACK_LOCALE=de
          APP_FAKER_LOCALE=de_DE

          APP_MAINTENANCE_DRIVER=file
          PHP_CLI_SERVER_WORKERS=4
          BCRYPT_ROUNDS=12

          LOG_CHANNEL=stack
          LOG_STACK=single
          LOG_DEPRECATIONS_CHANNEL=null
          LOG_LEVEL=error

          DB_CONNECTION=mysql
          DB_HOST="${{ secrets.DB_HOST }}"
          DB_PORT="${{ secrets.DB_PORT }}"
          DB_DATABASE="${{ secrets.DB_DATABASE }}"
          DB_USERNAME="${{ secrets.DB_USERNAME }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_SOCKET=
          DB_CHARSET=utf8mb4
          DB_COLLATION=utf8mb4_unicode_ci
          DB_PREFIX=
          DB_STRICT_MODE=false
          DB_ENGINE=

          SESSION_DRIVER=file
          SESSION_LIFETIME=120
          SESSION_ENCRYPT=false
          SESSION_PATH=/
          SESSION_DOMAIN="${{ secrets.SESSION_DOMAIN }}"

          BROADCAST_CONNECTION=log
          FILESYSTEM_DISK=local
          QUEUE_CONNECTION=database
          CACHE_STORE=file

          MAIL_MAILER=smtp
          MAIL_HOST="${{ secrets.MAIL_HOST }}"
          MAIL_PORT="${{ secrets.MAIL_PORT }}"
          MAIL_USERNAME="${{ secrets.MAIL_USERNAME }}"
          MAIL_PASSWORD="${{ secrets.MAIL_PASSWORD }}"
          MAIL_ENCRYPTION=tls
          MAIL_FROM_ADDRESS="${{ secrets.MAIL_FROM_ADDRESS }}"
          MAIL_FROM_NAME="${{ secrets.APP_NAME }}"

          VITE_APP_NAME="${{ secrets.APP_NAME }}"

          # Admin User Configuration
          ADMIN_NAME="Super Admin"
          ADMIN_EMAIL="admin@lexarbitra.com"
          ADMIN_PASSWORD="admin123!"
          ADMIN_TITLE="Administrator"
          ADMIN_LAW_FIRM=""
          ADMIN_PHONE=""
          ADMIN_ADDRESS=""
          ADMIN_BAR_NUMBER=""

          # KAS API Configuration for database creation
          KAS_USER="${{ secrets.KAS_USER }}"
          KAS_PASSWORD="${{ secrets.KAS_PASSWORD }}"
          KAS_API_URL=https://kasapi.kasserver.com/soap/
          KAS_WSDL_URL=https://kasapi.kasserver.com/soap/api.wsdl
          EOF

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

          # Test SSH connection
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.USERNAME }}@${{ secrets.HOST }} "echo 'SSH connection successful'"

      - name: Create backup on server
        run: |
          ssh ${{ secrets.USERNAME }}@${{ secrets.HOST }} << 'EOF'
            cd ${{ secrets.PROJECT_PATH }}

            # Create backup directory
            mkdir -p backups

            # Create timestamped backup if app exists
            if [[ -d "app" ]]; then
              TIMESTAMP=$(date +%Y%m%d_%H%M%S)
              echo "Creating backup: backups/backup_${TIMESTAMP}.tar.gz"
              tar -czf backups/backup_${TIMESTAMP}.tar.gz \
                app bootstrap config database resources routes storage vendor .env \
                composer.json composer.lock artisan public 2>/dev/null || true

              # Keep only last 5 backups
              cd backups
              ls -t backup_*.tar.gz | tail -n +6 | xargs rm -f -- 2>/dev/null || true
            fi
          EOF

      - name: Deploy application
        run: |
          # Upload Laravel application files to a subdirectory
          rsync -avz --delete-after \
            --exclude="storage/app/public/documents" \
            --exclude="storage/logs" \
            --exclude="storage/framework/cache" \
            --exclude="storage/framework/sessions" \
            --exclude="storage/framework/views" \
            --exclude="public/*" \
            deployment-package/ ${{ secrets.USERNAME }}@${{ secrets.HOST }}:${{ secrets.PROJECT_PATH }}/laravel/

          # Upload public folder contents to domain root
          rsync -avz \
            deployment-package/public/ ${{ secrets.USERNAME }}@${{ secrets.HOST }}:${{ secrets.PROJECT_PATH }}/

          # Also copy build assets to Laravel's expected location
          rsync -avz \
            deployment-package/public/build/ ${{ secrets.USERNAME }}@${{ secrets.HOST }}:${{ secrets.PROJECT_PATH }}/laravel/public/build/ 2>/dev/null || echo "No build directory found"

      - name: Configure application on server
        run: |
          ssh ${{ secrets.USERNAME }}@${{ secrets.HOST }} << 'EOF'
            # Configure Laravel application (now in laravel/ subdirectory)
            cd ${{ secrets.PROJECT_PATH }}/laravel

            # Set proper permissions for Laravel files
            chmod -R 755 storage bootstrap/cache

            # Create necessary directories
            mkdir -p storage/logs
            mkdir -p storage/framework/{cache,sessions,views}
            mkdir -p storage/app/public/documents
            mkdir -p public/build

            # Create basic Vite manifest if missing
            if [[ ! -f public/build/manifest.json ]]; then
              echo '{}' > public/build/manifest.json
              echo "Created empty Vite manifest for compatibility"
            fi

            # Generate application key if not exists
            php artisan key:generate --force --no-interaction

            # Clear configuration only (don't clear database cache before migrations)
            php artisan config:clear --no-interaction || true
            php artisan route:clear --no-interaction || true

            # Verify the APP_KEY was generated
            echo "APP_KEY check:"
            grep "APP_KEY=" .env || echo "No APP_KEY found in .env"

            # Create storage symlink in both locations
            cd ${{ secrets.PROJECT_PATH }}
            ln -sf laravel/storage/app/public storage

            # Also create storage link in the Laravel public directory
            cd ${{ secrets.PROJECT_PATH }}/laravel
            php artisan storage:link --no-interaction || true

            # Create a proper index.php for all-inkl structure
            cd ${{ secrets.PROJECT_PATH }}
            echo "<?php" > index.php
            echo "use Illuminate\\Contracts\\Http\\Kernel;" >> index.php
            echo "use Illuminate\\Http\\Request;" >> index.php
            echo "define('LARAVEL_START', microtime(true));" >> index.php
            echo "if (file_exists(\$maintenance = __DIR__.'/laravel/storage/framework/maintenance.php')) {" >> index.php
            echo "    require \$maintenance;" >> index.php
            echo "}" >> index.php
            echo "require __DIR__.'/laravel/vendor/autoload.php';" >> index.php
            echo "\$app = require_once __DIR__.'/laravel/bootstrap/app.php';" >> index.php
            echo "\$kernel = \$app->make(Kernel::class);" >> index.php
            echo "\$response = \$kernel->handle(\$request = Request::capture())->send();" >> index.php
            echo "\$kernel->terminate(\$request, \$response);" >> index.php

            # Debug: Show the created index.php
            echo "=== Created index.php content ==="
            head -10 index.php

            # Set proper permissions for web files
            find . -type f -exec chmod 644 {} \;
            find . -type d -exec chmod 755 {} \;
            chmod -R 755 laravel/storage laravel/bootstrap/cache
          EOF

      - name: Run database migrations
        run: |
          ssh ${{ secrets.USERNAME }}@${{ secrets.HOST }} << 'EOF'
            cd ${{ secrets.PROJECT_PATH }}/laravel

            # Test database connection
            echo "=== Database Connection Debugging ==="
            echo "Current directory: $(pwd)"
            echo "Environment check:"
            grep "DB_" .env | head -10

            echo "Testing raw PHP MySQL connection..."
            php -r "
            \$host = '$(grep DB_HOST .env | cut -d= -f2)';
            \$port = '$(grep DB_PORT .env | cut -d= -f2)';
            \$database = '$(grep DB_DATABASE .env | cut -d= -f2)';
            \$username = '$(grep DB_USERNAME .env | cut -d= -f2)';
            \$password = '$(grep DB_PASSWORD .env | cut -d= -f2)';

            echo 'Attempting connection to: ' . \$host . ':' . \$port . ' with database: ' . \$database . PHP_EOL;

            try {
                \$mysqli = new mysqli(\$host, \$username, \$password, \$database, \$port);
                if (\$mysqli->connect_error) {
                    echo 'Connection failed: ' . \$mysqli->connect_error . PHP_EOL;
                } else {
                    echo 'Raw MySQL connection successful!' . PHP_EOL;
                    echo 'Server info: ' . \$mysqli->server_info . PHP_EOL;
                    \$mysqli->close();
                }
            } catch (Exception \$e) {
                echo 'Exception: ' . \$e->getMessage() . PHP_EOL;
            }
            "

            echo "Testing Laravel database connection..."
            php artisan tinker --execute="
            try {
                \$pdo = DB::connection()->getPdo();
                echo 'Laravel DB connection successful with driver: ' . \$pdo->getAttribute(PDO::ATTR_DRIVER_NAME) . PHP_EOL;
                echo 'Server info: ' . \$pdo->getAttribute(PDO::ATTR_SERVER_INFO) . PHP_EOL;
            } catch (Exception \$e) {
                echo 'Laravel DB connection failed: ' . \$e->getMessage() . PHP_EOL;
                echo 'Config values:' . PHP_EOL;
                echo 'DB_HOST: ' . config('database.connections.mysql.host') . PHP_EOL;
                echo 'DB_PORT: ' . config('database.connections.mysql.port') . PHP_EOL;
                echo 'DB_DATABASE: ' . config('database.connections.mysql.database') . PHP_EOL;
                echo 'DB_USERNAME: ' . config('database.connections.mysql.username') . PHP_EOL;
                throw \$e;
            }
            "

            # Run migrations on MASTER database only
            echo "🚀 Running database migrations..."
            php artisan migrate --force --no-interaction

            # Seed the database (includes admin user)
            echo "🌱 Seeding database..."
            php artisan db:seed --no-interaction || echo "Seeding failed, attempting to create admin user manually"

            # Manually create admin user if seeding failed
            echo "Checking admin user creation..."
            php artisan tinker --execute="
            try {
                \$adminEmail = env('ADMIN_EMAIL', 'admin@lexarbitra.com');
                \$existingUser = \App\Models\User::where('email', \$adminEmail)->first();

                if (\$existingUser) {
                    echo 'Admin user already exists: ' . \$existingUser->email . PHP_EOL;
                } else {
                    \$admin = \App\Models\User::create([
                        'name' => env('ADMIN_NAME', 'Super Admin'),
                        'email' => \$adminEmail,
                        'password' => \Illuminate\Support\Facades\Hash::make(env('ADMIN_PASSWORD', 'admin123!')),
                        'email_verified_at' => now(),
                        'is_super_admin' => true,
                        'is_active' => true,
                        'title' => 'Administrator',
                    ]);
                    echo 'Admin user created manually: ' . \$admin->email . PHP_EOL;
                }

                echo 'Total users in database: ' . \App\Models\User::count() . PHP_EOL;
            } catch (Exception \$e) {
                echo 'Error creating admin user: ' . \$e->getMessage() . PHP_EOL;
            }
            "

            # Test KAS API connection
            php artisan tinker --execute="app(\App\Services\KasApiService::class)->testConnection();" || echo "KAS API connection test failed - check credentials"

            # Clear and rebuild autoloader
            composer dump-autoloader --optimize --no-dev

            # Verify APP_KEY is still set before caching
            echo "Final APP_KEY check before caching:"
            grep "APP_KEY=" .env || echo "No APP_KEY found in .env"

            # Cache configuration
            php artisan config:cache --no-interaction
            php artisan route:cache --no-interaction
            php artisan view:cache --no-interaction

            echo "✅ Database migrations completed successfully!"
          EOF

      # - name: Test deployment
      #   run: |
      #     # Test the application is responding
      #     curl -f -s -o /dev/null ${{ secrets.APP_URL }} || (echo "Application not responding" && exit 1)
      #     echo "✅ Application is responding successfully"

      - name: Notify deployment status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "🚀 Deployment to production completed successfully!"
            echo "📍 Application URL: ${{ secrets.APP_URL }}"
          else
            echo "❌ Deployment failed. Check the logs above."
            exit 1
          fi

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'staging' && github.event_name == 'workflow_dispatch'

    environment:
      name: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          echo "🚧 Staging deployment would run here"
          echo "This is a placeholder for staging deployment steps"
          # Similar steps to production but with staging secrets